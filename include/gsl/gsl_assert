///////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 2015 Microsoft Corporation. All rights reserved.
//
// This code is licensed under the MIT License (MIT).
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//
///////////////////////////////////////////////////////////////////////////////

#ifndef GSL_CONTRACTS_H
#define GSL_CONTRACTS_H

#include <exception>
#include <stdexcept> // for logic_error

//
// Temporary until MSVC STL supports no-exceptions mode.
// Currently terminate is a no-op in this mode, so we add termination behavior back
//
#if defined(_MSC_VER) && defined(_HAS_EXCEPTIONS) && !_HAS_EXCEPTIONS
#define GSL_MSVC_USE_STL_NOEXCEPTION_WORKAROUND
#endif

//
// There are three configuration options for this GSL implementation's behavior
// when pre/post conditions on the GSL types are violated:
//
// 1. GSL_TERMINATE_ON_CONTRACT_VIOLATION: std::terminate will be called (default)
// 2. GSL_THROW_ON_CONTRACT_VIOLATION: a gsl::fail_fast exception will be thrown
// 3. GSL_UNENFORCED_ON_CONTRACT_VIOLATION: nothing happens
//
#if !(defined(GSL_THROW_ON_CONTRACT_VIOLATION) || defined(GSL_TERMINATE_ON_CONTRACT_VIOLATION) ||  \
      defined(GSL_UNENFORCED_ON_CONTRACT_VIOLATION))
#define GSL_TERMINATE_ON_CONTRACT_VIOLATION
#endif

#define GSL_STRINGIFY_DETAIL(x) #x
#define GSL_STRINGIFY(x) GSL_STRINGIFY_DETAIL(x)

#if defined(__clang__) || defined(__GNUC__)
#define GSL_LIKELY(x) __builtin_expect(!!(x), 1)
#define GSL_UNLIKELY(x) __builtin_expect(!!(x), 0)
#else
#define GSL_LIKELY(x) (!!(x))
#define GSL_UNLIKELY(x) (!!(x))
#endif

//
// GSL_ASSUME(cond)
//
// Tell the optimizer that the predicate cond must hold. It is unspecified
// whether or not cond is actually evaluated.
//
#ifdef _MSC_VER
#define GSL_ASSUME(cond) __assume(cond)
#elif defined(__GNUC__)
#define GSL_ASSUME(cond) ((cond) ? static_cast<void>(0) : __builtin_unreachable())
#else
#define GSL_ASSUME(cond) static_cast<void>((cond) ? 0 : 0)
#endif

//
// GSL.assert: assertions
//

namespace gsl
{
struct fail_fast : public std::logic_error
{
    explicit fail_fast(char const* const message) : std::logic_error(message) {}
};

namespace details
{
#if defined(GSL_MSVC_USE_STL_NOEXCEPTION_WORKAROUND)

    typedef void  (*terminate_handler)();

    inline gsl::details::terminate_handler& get_terminate_handler() noexcept
    {
        static terminate_handler handler = &abort;
        return handler;
    }

#endif

    [[noreturn]] inline void terminate() noexcept
    {
#if defined(GSL_MSVC_USE_STL_NOEXCEPTION_WORKAROUND)
        (*gsl::details::get_terminate_handler())();
#else
        std::terminate();
#endif
    }

#if defined(GSL_TERMINATE_ON_CONTRACT_VIOLATION)

    template <typename Exception>
    [[noreturn]] void throw_exception(Exception&&)
    {
        gsl::details::terminate();
    }

#else

    template <typename Exception>
    [[noreturn]] void throw_exception(Exception&& exception)
    {
        throw exception;
    }

#endif

    constexpr bool noexcept_test(bool cond) noexcept { return cond; }

} // namespace details
} // namespace gsl

#if __cplusplus >= 201703L || _MSVC_LANG >= 201703 || defined(__cpp_lib_uncaught_exceptions)
#define GSL_UNCAUGHT_EXCEPTIONS std::uncaught_exceptions
#else
inline int GSL_UNCAUGHT_EXCEPTIONS() { return std::uncaught_exceptions(); }
#endif

#if defined(GSL_THROW_ON_CONTRACT_VIOLATION)
#define GSL_CONTRACT_FAIL(type) gsl::details::throw_exception(gsl::fail_fast(                      \
    "GSL: " type " failure at " __FILE__ ": " GSL_STRINGIFY(__LINE__)))
#elif defined(GSL_TERMINATE_ON_CONTRACT_VIOLATION)
#define GSL_CONTRACT_FAIL(type) gsl::details::terminate()
#endif

#if defined(GSL_THROW_ON_CONTRACT_VIOLATION) || defined(GSL_TERMINATE_ON_CONTRACT_VIOLATION)

#define GSL_CONTRACT_CHECK(type, cond)                                                             \
    (GSL_LIKELY(cond) || GSL_UNCAUGHT_EXCEPTIONS() > GSL_UNIQUE(GSL_NUM_UNCAUGHT_) ?               \
      static_cast<void>(0) : GSL_CONTRACT_FAIL(type))

// Same as above, but contract fails even when exiting via exception
// Throwing in this case will call std::terminate
#if __cplusplus >= 201703L || _MSVC_LANG >= 201703 || __cpp_constexpr >= 201603
#define GSL_CONTRACT_CHECK_ALWAYS(type, cond)                                                      \
    (GSL_LIKELY([&]() noexcept {return (cond);}()) ?                                               \
      static_cast<void>(0) : GSL_CONTRACT_FAIL(type))
#else
#define GSL_CONTRACT_CHECK_ALWAYS(type, cond)                                                      \
    (GSL_LIKELY(cond) ?                                                                            \
      static_cast<void>(0) : GSL_CONTRACT_FAIL(type))
#endif

#elif defined(GSL_UNENFORCED_ON_CONTRACT_VIOLATION)

#define GSL_CONTRACT_CHECK(type, cond)        GSL_ASSUME(cond)
#define GSL_CONTRACT_CHECK_ALWAYS(type, cond) GSL_ASSUME(cond)

#endif

#define Expects(cond) GSL_CONTRACT_CHECK_ALWAYS("Precondition", cond)

#if defined(GSL_UNENFORCED_ON_CONTRACT_VIOLATION)

#define Ensures(cond)         static_cast<void>(0)
#define AlwaysEnsures(cond)   static_cast<void>(0)

#else // GSL_UNENFORCED_ON_CONTRACT_VIOLATION

// Ensures uses an object that checks the condition on destruction
template<class A> class gsl_ensurer {
    gsl_ensurer           (const gsl_ensurer&) = delete;
    gsl_ensurer& operator=(const gsl_ensurer&) = delete;
    A& asserter;
public:
    gsl_ensurer(A& a) : asserter(a) {}
    ~gsl_ensurer() noexcept(false)
    { asserter(); }
};

// Use line numbers to create unique names for each ensurer.
#define GSL_UNIQUE(a) GSL_JOIN(a, __LINE__)
#define GSL_JOIN(a, b) GSL_PASTE(a, b)
#define GSL_PASTE(a, b) a##b

// Ensure along all non-exception exit paths.
#define Ensures(cond)                                                                              \
    const int GSL_UNIQUE(GSL_NUM_UNCAUGHT_) = GSL_UNCAUGHT_EXCEPTIONS();                           \
    auto GSL_UNIQUE(GSL_ENSURER_) = [&]() {                                                        \
        GSL_CONTRACT_CHECK("Postcondition", cond);                                                 \
    };                                                                                             \
    gsl_ensurer<decltype(GSL_UNIQUE(GSL_ENSURER_))>                                                \
        GSL_UNIQUE(GSL_ENSURE_)(GSL_UNIQUE(GSL_ENSURER_));

// Ensure even when exiting via exception.
#define AlwaysEnsures(cond)                                                                        \
    auto GSL_UNIQUE(GSL_ENSURER_) = [&]() {                                                        \
        GSL_CONTRACT_CHECK_ALWAYS("Postcondition", cond);                                          \
    };                                                                                             \
    gsl_ensurer<decltype(GSL_UNIQUE(GSL_ENSURER_))>                                                \
        GSL_UNIQUE(GSL_ENSURE_)(GSL_UNIQUE(GSL_ENSURER_));

#endif // GSL_UNENFORCED_ON_CONTRACT_VIOLATION

// Assert that a function maintains an invariant during normal control flow
#define Maintains(cond)                                                                            \
    Expects(cond);                                                                                 \
    Ensures(cond)                                                                                  \

// Assert that the invariant is maintained even when exiting via exception
#define AlwaysMaintains(cond)                                                                      \
    Expects(cond);                                                                                 \
    AlwaysEnsures(cond)                                                                            \

#endif // GSL_CONTRACTS_H

